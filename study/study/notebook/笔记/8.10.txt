《操作符理解》


移位：
		左移右边补0；
		右移后{负数左边补符号位1}
		{正数补0}		/*负数以补码出现*/（如-1出现32个1）
		
		0异或（相同为0，反之为1）任何数都是这个数
		
sizeof:		
		sizeof 只在编译期间确定字节大小，不参与运算;
		{int arr[]或者是char ch[]-----------相当于int *arr和char *ch}
			因为数组名为数组首元素的地址
			
			这时又牵扯到了指针：
				例如int *p; （// 这是声明），*p 声明 p 是指针，p 只能用来指向 int 型地址
				int *p=arr; // 这是声明加初始化，*p 声明p 是指针，p 只能用来指向 int 型地址，
					初始化让它指向数组arr 的 首地址，也就是 p=&arr[0];
				
				*与++时同一优先级，又由于一元运算符具有由右向左结合性，而*p++ 等价于*（p++）,即先将指针后移，然后取值
				p++; // 这是语句，p 是地址， p++ 是 "p 的地址 加 sizeof(int)"
	
	
			区别：sizeof用来取得变量或类型所占用的内存大小(指针4个字节）（计算'\0')
					strlen 是返回字符串的长度(遇到‘\0’截止，不计算‘\0’长度）


		
		
逻辑与：
		表达式1  && 表达式2     短路与（若1式为假直接跳出）
逻辑或：
		表达式1   ||   表达式2       短路或（若1式为真直接跳出）
按位与：
		a & b		(例如3 & 4 == 0，3 & 4即二进制数011和100按位与，结果是二进制数000）
按位或：
		a | b		(3 | 4的值为7，3 | 4即二进制数011和100按位或，结果是二进制数111,类似加法）
		
		
		
条件表达式：
			表达式1 ? 表达式2 : 表达式3
			例如：	a>b ? a ：b		判断a是否大于1,true输出a,反之输出b 
			
			
逗号表达式：	
			只执行逗号最后的表达式（但是之前的还是会进行操作）			
			
		
		
下标引用：
		
		若定义变量struct Stu stu;		stu.age = 20;//结构成员访问
		若定义指针struct Stu* pStu = &stu;		pStu->age = 20;//结构成员访问
						也可写做：struct Stu （*pStu）.age = 20（因为.的优先级高，加括号）
		
		
		
		
		指向符->自带解引用（中括号[]也自带解引用）;
		
		
添加问题：
		不能使用if for 大于 等于 小于等运算符 
		判断两个数的大小？
		a>b       1
		a == b   0
		a < b    -1

		
int Func(int a,int b)
{
	return (a-b)>>31 ? -1 : (a-b ? 1 : 0);
	//                         ? 小于 ：大于等于
}
		
		
		
		

整形提升（参与表达式运算,就会发生整形提升）：
		eg:
			char a = -1;
			将int型的-1（32位）中8位给a,左边补符号位；
		
		隐式类型转换：
				
				eg:char a,b,c;	c = a+b; 
				提升为普通整型，然后再执行加法运算
		
		算术转换:
				如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数的转换为另一个操作数的类型，否则操作就
					无法进行
			 
		
		
		
		
		
		
		
		
		
		
		
		
		